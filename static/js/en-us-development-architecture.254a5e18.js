(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"./docs/langs/en-US/development/architecture.mdx":function(e,t,a){"use strict";a.r(t);var n=a("./node_modules/react/index.js"),r=a.n(n),s=a("./node_modules/@mdx-js/tag/dist/index.js");function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}t.default=function(e){var t=e.components;o(e,["components"]);return r.a.createElement(s.MDXTag,{name:"wrapper",components:t},r.a.createElement(s.MDXTag,{name:"h1",components:t,props:{id:"architecture"}},"Architecture"),r.a.createElement(s.MDXTag,{name:"h2",components:t,props:{id:"compilation"}},"Compilation"),r.a.createElement(s.MDXTag,{name:"p",components:t},"The compiler's structure is relatively conservative."),r.a.createElement(s.MDXTag,{name:"p",components:t},"Provided with a source file, its text is ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/src/tokenizer.ts"}},"tokenized")," and ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/src/parser.ts"}},"parsed")," into an ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/src/ast.ts"}},"abstract syntax tree"),". Syntax-level checking is performed here."),r.a.createElement(s.MDXTag,{name:"p",components:t},"Once all referenced source files have been parsed, ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/src/program.ts"}},"a program")," is constructed and initialized from the AST. Sanity checking is performed here. The program and its elements then act as the intermediate representation in code generation, holding all the information necessary to resolve types, identifiers, property accesses etc."),r.a.createElement(s.MDXTag,{name:"p",components:t},"Afterwards, ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/src/compiler.ts"}},"compilation")," of the program's elements to a ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/src/module.ts"}},"Binaryen module")," is performed. Final checking of individual statements and expressions is performed here. By default, compilation starts at entry file exports and then traverses reachable program elements (also known as \"tree shaking\"). Doing so on compiler level provides a significant speed advantage because dead code isn't compiled at all, but also has the drawback that dead code isn't fully checked. Yet, specifying ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"--noEmit --noTreeShaking")," checks everything without generating code."),r.a.createElement(s.MDXTag,{name:"p",components:t},"The resulting module may then be validated, optimized and emitted in all of Binaryen's various output formats (textual ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},".wat"),", binary ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},".wasm"),", asm.js ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},".js"),")."),r.a.createElement(s.MDXTag,{name:"h2",components:t,props:{id:"api"}},"API"),r.a.createElement(s.MDXTag,{name:"p",components:t},"The compiler itself exports a relatively low-level ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/src/index.ts"}},"C-like API")," that provides everything necessary to perform compilation in interchangeable JS/WASM environments."),r.a.createElement(s.MDXTag,{name:"p",components:t},"The low-level API is used by ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/blob/master/bin/asc.js"}},"asc"),", a compiler frontend for node, which exposes ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/tree/master/bin#api"}},"its CLI API")," programmatically as well."),r.a.createElement(s.MDXTag,{name:"h2",components:t,props:{id:"standard-library"}},"Standard library"),r.a.createElement(s.MDXTag,{name:"p",components:t},"While not fully figured out yet, standard library components reside in the ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/tree/master/std"}},"std")," folder and are available in two variations, ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"assembly")," for targeting WebAssembly with ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"asc")," and ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"portable")," for targeting JavaScript with ",r.a.createElement(s.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"tsc"),". The portable standard library basically declares what's already in the environment in an AssemblyScript-compatible way while the assembly standard library reimplements the same functionality in AssemblyScript for WebAssembly."))}}}]);