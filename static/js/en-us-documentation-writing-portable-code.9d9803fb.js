(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{"./docs/langs/en-US/documentation/writing-portable-code.mdx":function(e,n,a){"use strict";a.r(n);var t=a("./node_modules/react/index.js"),o=a.n(t),m=a("./node_modules/@mdx-js/tag/dist/index.js");function r(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},m=Object.keys(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}n.default=function(e){var n=e.components;r(e,["components"]);return o.a.createElement(m.MDXTag,{name:"wrapper",components:n},o.a.createElement(m.MDXTag,{name:"h1",components:n,props:{id:"writing-portable-code"}},"Writing Portable Code"),o.a.createElement(m.MDXTag,{name:"p",components:n},"When targeting both WebAssembly with ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"asc")," and JavaScript with ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"tsc"),", there are a few semantic differences to take care of."),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"explicit-conversions"}},"Explicit conversions"),o.a.createElement(m.MDXTag,{name:"p",components:n},"While ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"asc")," understands the meaning of"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts",metaString:""}},"// non-portable\nlet someFloat: f32 = 1.5;\nlet someInt: i32 = <i32>someFloat;\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},"and then inserts the correct conversion steps, ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"tsc")," does not because all numeric types are just aliases of ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"number"),". Hence, when targeting JavaScript with ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"tsc"),", the above will result in"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"// js\nvar someFloat = 1.5;\nvar someInt = someFloat;\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},"which is obviously wrong. To account for this, explicit conversions can be inserted, resulting in actually portable code. For example"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts",metaString:""}},"// portable\nlet someFloat: f32 = 1.5;\nlet someInt: i32 = (<i32>someFloat) | 0;\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},"will result in"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"// js\nvar someFloat = 1.5;\nvar someInt = 1.5 | 0;\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},"which is correct."),o.a.createElement(m.MDXTag,{name:"p",components:n},"Additionally, an equally named portable conversion function is present for each built-in type that transforms any other built-in type to a value of the target type:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts",metaString:""}},"// using a portable conversion function\nlet someFloat: f32 = 1.5;\nlet someInt: i32 = i32(someFloat);\n")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"overflows"}},"Overflows"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Likewise, again because ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"asc")," knows the meaning but ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"tsc")," does not, overflows must be handled explicitly:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts",metaString:""}},"// non-portable\nlet someU8: u8 = 255;\nlet someOtherU8: u8 = someU8 + 1;\n")),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts",metaString:""}},"// portable\nlet someU8: u8 = 255;\nlet someOtherU8: u8 = (someU8 + 1) & 0xff;\n")),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts",metaString:""}},"// using a portable conversion function\nlet someU8: u8 = 255;\nlet someOtherU8: u8 = u8(someU8 + 1);\n")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"non-portable-operations"}},"Non portable operations"),o.a.createElement(m.MDXTag,{name:"p",components:n},"In JavaScript, all numeric values are IEEE754 doubles that cannot represent the full range of values fitting in a 64-bit integer (",o.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER"}},"max. safe integer")," is 2^53-1). Hence ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"i64")," and ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"u64")," are not portable and not present in ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"std/portable.d.ts"),". There are several ways to deal with this. One is to use an i64 polyfill like ",o.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/AssemblyScript/assemblyscript/tree/master/examples/i64-polyfill"}},"in this example"),"."),o.a.createElement(m.MDXTag,{name:"p",components:n},"Other than that, some generic built-in functions do not support the full range of type arguments. For example:"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"li"},"load"),"<",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"T = u8"),">(offset: ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"usize"),"): ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"T")," - and - ",o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"li"},"store"),"<",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"T = u8"),">(offset: ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"usize"),", value: ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"T"),"): ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"void"),o.a.createElement("br",null),"\nare limited to ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"u8")," because the type argument cannot be evaluated in JS.")))}}}]);